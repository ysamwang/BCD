mu.hat <- optim_out$par[1:V]
B.hat <- matrix(0, nrow = V, ncol = V)
B.hat[which(B==1)] <- optim_out$par[-c(1:V)]
S.hat <- (Y - mu.hat) %*% diag(c(1.0/fitted_mod$d)) %*% t(Y- mu.hat)
Omega.hat <- (diag(rep(1,V)) - B.hat) %*% S.hat %*% t((diag(rep(1,V)) - B.hat))
sw <- empLike_sandwich(Y, B, Omega, B.hat, mu.hat, c(1/fitted_mod$d))
se <- sqrt(diag(sw$sw.var)/n)
cover <- c(mu.hat,
optim_out$par[-c(1:V)] - B.weights[which(B==1)])
ci <- ci + (abs(cover) < qnorm(.975))
el_om <- el_om + mean(((Omega.hat - Omega.weights) * Omega)^2)
el_b <- el_b + mean(((B.hat - B.weights) * B)^2)
init_om <- init_om + mean(((out_ricf_init$OmegaHat - Omega.weights) * Omega)^2)
init_b <- init_b + mean(((out_ricf_init$BHat - B.weights) * B)^2)
}
ci / sim.size
el_om / sim.size
el_b / sim.size
init_om / sim.size
init_b / sim.size
set.seed(111)
library(MASS)
V <- 5
n <- 200
Omega <- matrix(0, nrow = V, ncol = V)
Omega[lower.tri(Omega)] <- rbinom(n = V*(V-1)/2, size = 1, prob = .3)
Omega.weights <- matrix(runif(V^2), nrow = V)
Omega.weights <- Omega.weights %*% t(Omega.weights)
Omega <- Omega + diag(rep(1,V)) + t(Omega)
Omega.weights <- Omega * Omega.weights
B <- matrix(0,nrow = V, ncol = V)
B[which(Omega==0)] <- rbinom(n = V^2-sum(Omega), size = 1, prob = .2)
B.weights <- matrix(rnorm(V^2), nrow = V) * B
sigma <- solve(diag(rep(1,V)) - B.weights) %*% Omega.weights %*% t(solve(diag(rep(1,V)) - B.weights))
ci <- rep(0, V + sum(B))
init_b <- init_om <- el_b <- el_om <- 0
sim.size <- 200
for(i in 1:sim.size){
Y <- t(mvrnorm(n = n, mu = rep(0, V), Sigma = sigma))
Y <- Y - rowMeans(Y)
#####
out_ricf_init <- ricf(B = B, Omega = Omega, Y = Y, BInit = NULL,
OmegaInit = NULL, sigConv = 0, maxIter = 1,
msgs = FALSE, omegaInitScale = .9)
num_dual_vars = V + sum(Omega == 0)/2
init_val = c(rep(0,V), out_ricf_init$BHat[B==1])
optim_out <- optim(par = init_val, fn = sem_el_fit_obj, gr = NULL,
y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-6, max_iter = 60,
method = "BFGS", control = list(fnscale = -1))
fitted_mod <- sem_el_fit_weights(optim_out$par, y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-10, max_iter = 100)
mu.hat <- optim_out$par[1:V]
B.hat <- matrix(0, nrow = V, ncol = V)
B.hat[which(B==1)] <- optim_out$par[-c(1:V)]
S.hat <- (Y - mu.hat) %*% diag(c(1.0/fitted_mod$d)) %*% t(Y- mu.hat)
Omega.hat <- (diag(rep(1,V)) - B.hat) %*% S.hat %*% t((diag(rep(1,V)) - B.hat))
sw <- empLike_sandwich(Y, B, Omega, B.hat, mu.hat, c(1/fitted_mod$d))
se <- sqrt(diag(sw$sw.var)/n)
cover <- c(mu.hat,
optim_out$par[-c(1:V)] - B.weights[which(B==1)])
ci <- ci + (abs(cover) < qnorm(.975))
el_om <- el_om + mean(((Omega.hat - Omega.weights) * Omega)^2)
el_b <- el_b + mean(((B.hat - B.weights) * B)^2)
init_om <- init_om + mean(((out_ricf_init$OmegaHat - Omega.weights) * Omega)^2)
init_b <- init_b + mean(((out_ricf_init$BHat - B.weights) * B)^2)
}
ci / sim.size
el_om / sim.size
el_b / sim.size
init_om / sim.size
init_b / sim.size
set.seed(111)
library(MASS)
V <- 5
n <- 500
Omega <- matrix(0, nrow = V, ncol = V)
Omega[lower.tri(Omega)] <- rbinom(n = V*(V-1)/2, size = 1, prob = .3)
Omega.weights <- matrix(runif(V^2), nrow = V)
Omega.weights <- Omega.weights %*% t(Omega.weights)
Omega <- Omega + diag(rep(1,V)) + t(Omega)
Omega.weights <- Omega * Omega.weights
B <- matrix(0,nrow = V, ncol = V)
B[which(Omega==0)] <- rbinom(n = V^2-sum(Omega), size = 1, prob = .2)
B.weights <- matrix(rnorm(V^2), nrow = V) * B
sigma <- solve(diag(rep(1,V)) - B.weights) %*% Omega.weights %*% t(solve(diag(rep(1,V)) - B.weights))
ci <- rep(0, V + sum(B))
init_b <- init_om <- el_b <- el_om <- 0
sim.size <- 200
for(i in 1:sim.size){
Y <- t(mvrnorm(n = n, mu = rep(0, V), Sigma = sigma))
Y <- Y - rowMeans(Y)
#####
out_ricf_init <- ricf(B = B, Omega = Omega, Y = Y, BInit = NULL,
OmegaInit = NULL, sigConv = 0, maxIter = 1,
msgs = FALSE, omegaInitScale = .9)
num_dual_vars = V + sum(Omega == 0)/2
init_val = c(rep(0,V), out_ricf_init$BHat[B==1])
optim_out <- optim(par = init_val, fn = sem_el_fit_obj, gr = NULL,
y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-6, max_iter = 60,
method = "BFGS", control = list(fnscale = -1))
fitted_mod <- sem_el_fit_weights(optim_out$par, y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-10, max_iter = 100)
mu.hat <- optim_out$par[1:V]
B.hat <- matrix(0, nrow = V, ncol = V)
B.hat[which(B==1)] <- optim_out$par[-c(1:V)]
S.hat <- (Y - mu.hat) %*% diag(c(1.0/fitted_mod$d)) %*% t(Y- mu.hat)
Omega.hat <- (diag(rep(1,V)) - B.hat) %*% S.hat %*% t((diag(rep(1,V)) - B.hat))
sw <- empLike_sandwich(Y, B, Omega, B.hat, mu.hat, c(1/fitted_mod$d))
se <- sqrt(diag(sw$sw.var)/n)
cover <- c(mu.hat,
optim_out$par[-c(1:V)] - B.weights[which(B==1)])
ci <- ci + (abs(cover) < qnorm(.975))
el_om <- el_om + mean(((Omega.hat - Omega.weights) * Omega)^2)
el_b <- el_b + mean(((B.hat - B.weights) * B)^2)
init_om <- init_om + mean(((out_ricf_init$OmegaHat - Omega.weights) * Omega)^2)
init_b <- init_b + mean(((out_ricf_init$BHat - B.weights) * B)^2)
}
ci / sim.size
el_om / sim.size
el_b / sim.size
init_om / sim.size
init_b / sim.size
library(BCD)
sw <- empLike_sandwich(Y, B, Omega, B.hat, mu.hat, c(1/fitted_mod$d))
Y - B.hat %*% Y
errors <- Y - B.hat %*% Y
rowMeans(errors)
er1 <- Y - B.hat %*% Y
rowMeans(er1)
mu.hat
errors <- errors - mu.hat
rowMeans(errors)
B.hat
(diag(rep(1,V)) - B.hat) %*% Y %*% diag(c(1/fitted_mod$d))
temp <- (diag(rep(1,V)) - B.hat) %*% Y %*% diag(c(1/fitted_mod$d))
rowMeans(temp)
set.seed(111)
library(MASS)
V <- 5
n <- 500
Omega <- matrix(0, nrow = V, ncol = V)
Omega[lower.tri(Omega)] <- rbinom(n = V*(V-1)/2, size = 1, prob = .3)
Omega.weights <- matrix(runif(V^2), nrow = V)
Omega.weights <- Omega.weights %*% t(Omega.weights)
Omega <- Omega + diag(rep(1,V)) + t(Omega)
Omega.weights <- Omega * Omega.weights
B <- matrix(0,nrow = V, ncol = V)
B[which(Omega==0)] <- rbinom(n = V^2-sum(Omega), size = 1, prob = .2)
B.weights <- matrix(rnorm(V^2), nrow = V) * B
sigma <- solve(diag(rep(1,V)) - B.weights) %*% Omega.weights %*% t(solve(diag(rep(1,V)) - B.weights))
ci <- rep(0, V + sum(B))
init_b <- init_om <- el_b <- el_om <- 0
Y <- t(mvrnorm(n = n, mu = rep(0, V), Sigma = sigma))
Y <- Y - rowMeans(Y)
out_ricf_init <- ricf(B = B, Omega = Omega, Y = Y, BInit = NULL,
OmegaInit = NULL, sigConv = 0, maxIter = 1,
msgs = FALSE, omegaInitScale = .9)
num_dual_vars = V + sum(Omega == 0)/2
init_val = c(rep(0,V), out_ricf_init$BHat[B==1])
optim_out <- optim(par = init_val, fn = sem_el_fit_obj, gr = NULL,
y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-10, max_iter = 60,
method = "BFGS", control = list(fnscale = -1))
fitted_mod <- sem_el_fit_weights(optim_out$par, y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-14, max_iter = 100)
mu.hat <- optim_out$par[1:V]
B.hat <- matrix(0, nrow = V, ncol = V)
B.hat[which(B==1)] <- optim_out$par[-c(1:V)]
S.hat <- (Y - mu.hat) %*% diag(c(1.0/fitted_mod$d)) %*% t(Y- mu.hat)
library(BCD)
out_ricf_init <- ricf(B = B, Omega = Omega, Y = Y, BInit = NULL,
OmegaInit = NULL, sigConv = 0, maxIter = 1,
msgs = FALSE, omegaInitScale = .9)
num_dual_vars = V + sum(Omega == 0)/2
init_val = c(rep(0,V), out_ricf_init$BHat[B==1])
optim_out <- optim(par = init_val, fn = sem_el_fit_obj, gr = NULL,
y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-10, max_iter = 60,
method = "BFGS", control = list(fnscale = -1))
fitted_mod <- sem_el_fit_weights(optim_out$par, y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-14, max_iter = 100)
mu.hat <- optim_out$par[1:V]
B.hat <- matrix(0, nrow = V, ncol = V)
B.hat[which(B==1)] <- optim_out$par[-c(1:V)]
S.hat <- (Y - mu.hat) %*% diag(c(1.0/fitted_mod$d)) %*% t(Y- mu.hat)
S.hat
mu.hat <- optim_out$par[1:V]
B.hat <- matrix(0, nrow = V, ncol = V)
B.hat[which(B==1)] <- optim_out$par[-c(1:V)]
B.hat
mu.hat
optim_out$par
temp <- (diag(rep(1,V))- B) %*% Y
dim(temp)
rowSums(temp)
rowMeans(temp)
temp <- temp - mu.hat
rowMeans(temp)
rowSums(temp)
library(BCD)
fitted_mod <- sem_el_fit_weights(optim_out$par, y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-14, max_iter = 100)
library(BCD)
Y <- t(mvrnorm(n = n, mu = rep(0, V), Sigma = sigma))
Y <- Y - rowMeans(Y)
#####
out_ricf_init <- ricf(B = B, Omega = Omega, Y = Y, BInit = NULL,
OmegaInit = NULL, sigConv = 0, maxIter = 1,
msgs = FALSE, omegaInitScale = .9)
num_dual_vars = V + sum(Omega == 0)/2
init_val = c(out_ricf_init$BHat[B==1])
optim_out <- optim(par = init_val, fn = sem_el_fit_obj, gr = NULL,
y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-10, max_iter = 60, meanEst = 0,
method = "BFGS", control = list(fnscale = -1))
fitted_mod <- sem_el_fit_weights(optim_out$par, y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-14, max_iter = 100, meanEst = 0)
optim_out$par
B.weights
num_dual_vars = V + sum(Omega == 0)/2
init_val = c(out_ricf_init$BHat[B==1])
optim_out <- optim(par = init_val, fn = sem_el_fit_obj, gr = NULL,
y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-10, max_iter = 60, meanEst = 0,
method = "BFGS", control = list(fnscale = -1))
fitted_mod <- sem_el_fit_weights(optim_out$par, y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-14, max_iter = 100, meanEst = 0)
optim_out$par
init_val
optim_out$par
optim_out
fitted_mod <- sem_el_fit_weights(optim_out$par, y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-14, max_iter = 100, meanEst = 0)
fitted_mod$d
1/fitted_mod$d
sum(1/fitted_mod$d)
optim_out <- optim(par = init_val, fn = sem_el_fit_obj, gr = NULL,
y_r = Y, omega_r = Omega, b_r = B,
dual_r = rep(0, num_dual_vars), tol = 1e-10, max_iter = 60, meanEst = 0,
method = "BFGS", control = list(fnscale = -1))
optim_out
library(Rcpp)
code <- '
void test(double a){
arma::vec x(5, arma::fill::ones);
x.each_col() += a;
Rcpp::Rcout <<vec <<std::endl;
}'
cppFunction(code, plugins = "RcppArmadillo")
library(Rcpp)
code <- '
void test(double a){
arma::vec x(5, arma::fill::ones);
x.each_col() += a;
Rcpp::Rcout <<vec <<std::endl;
}'
cppFunction(code, depends = "RcppArmadillo")
library(BCD)
source("tests/simHelper.R")
set.seed(111)
V <- 5
n <- 200
k <- 2
b <- .2
d <- .2
dist <- "gauss"
mod <- generateModel(v = V, n = n, k = k, b = b, d = d, errorDist = dist)
sim.size <- 200
Sigma <- solve(diag(rep(1, V)) - mod$B.true) %*% mod$Omega.true %*% t(solve(diag(rep(1, V)) - mod$B.true))
mse.like <- mse.el <- mse.init <- bias.like <- bias.init <- bias.el <- rep(0, sim.size)
Y <- t(MASS::mvrnorm(n = n, Sigma = Sigma, mu = rep(0, V)))
Y <- Y - rowMeans(Y)
#### RICF Procedure ####
out_ricf <- ricf(B = mod$B, Omega = mod$Omega, Y = Y, BInit = NULL,
OmegaInit = NULL, sigConv = 0, maxIter = 10000,
msgs = FALSE, omegaInitScale = .8, tol = 1e-6)
# I <- ricf_info(S = mod$Sigma, OmegaHat = mod$Omega.true , BHat = out_ricf$BHat, B = mod$B)
beta.like <- out_ricf$BHat[which(mod$B==1)]
mse.like[i] <-  mean((beta.like - mod$B.true[which(mod$B==1)])^2)
bias.like[i] <- mean(beta.like - mod$B.true[which(mod$B==1)])
i <- 1
Y <- Y - rowMeans(Y)
#### RICF Procedure ####
out_ricf <- ricf(B = mod$B, Omega = mod$Omega, Y = Y, BInit = NULL,
OmegaInit = NULL, sigConv = 0, maxIter = 10000,
msgs = FALSE, omegaInitScale = .8, tol = 1e-6)
# I <- ricf_info(S = mod$Sigma, OmegaHat = mod$Omega.true , BHat = out_ricf$BHat, B = mod$B)
beta.like <- out_ricf$BHat[which(mod$B==1)]
mse.like[i] <-  mean((beta.like - mod$B.true[which(mod$B==1)])^2)
bias.like[i] <- mean(beta.like - mod$B.true[which(mod$B==1)])
I <- ricf_info(S = mod$Sigma, OmegaHat = mod$Omega.true , BHat = out_ricf$BHat, B = mod$B)
I <- ricf_info(S = mod$Sigma, BHat = out_ricf$BHat, OmegaHat = mod$Omega.true,
B = mod$B, Omega = mod$Omega)
Omega.temp
z <- matrix(5, nrow = 2, ncol = 3)
z[0,0]
z[0,0] <- 1
z
z[5,0] <- 1
z[2,0] <- 1
z
Omega.temp <- matrix(0, nrow = V, ncol = V)
count <- 0
for(i in 1:V){
for(j in i:V){
if(Omega[i,j] == 1){
count <- count + 1
Omega.temp[i,j] <- count
}
}
}
Omega.temp <- Omega.temp + t(Omega.temp) - diag(diag(Omega.temp))
Omega <- mod$Omega
Omega.temp <- matrix(0, nrow = V, ncol = V)
count <- 0
for(i in 1:V){
for(j in i:V){
if(Omega[i,j] == 1){
count <- count + 1
Omega.temp[i,j] <- count
}
}
}
Omega.temp <- Omega.temp + t(Omega.temp) - diag(diag(Omega.temp))
Omega.temp
cbind(c(1:V^2)), c(Omega.temp))
cbind(c(1:V^2), c(Omega.temp))
Q[cbind(c(1:V^2), c(Omega.temp))] <- 1
Q <- matrix(0, nrow = V^2, ncol = (sum(Omega)-V)/2 + V)
Q[cbind(c(1:V^2), c(Omega.temp))] <- 1
Q
Q %*% c(1:7)
Omega.temp
(Q %*% c(1:7)) == c(Omega.temp)
library(BCD)
I <- ricf_info(S = mod$Sigma, BHat = out_ricf$BHat, OmegaHat = mod$Omega.true,
B = mod$B, Omega = mod$Omega)
I
solve(I)
sum(B)
sum(mod$B)
diag(solve(I))[1:3]
diag(solve(I[1:3,1:3]))
se.like <- sqrt(diag(solve(I))/n)
se.like
source("tests/simHelper.R")
set.seed(111)
V <- 5
n <- 200
k <- 2
b <- .2
d <- .2
dist <- "gauss"
mod <- generateModel(v = V, n = n, k = k, b = b, d = d, errorDist = dist)
sim.size <- 200
Sigma <- solve(diag(rep(1, V)) - mod$B.true) %*% mod$Omega.true %*% t(solve(diag(rep(1, V)) - mod$B.true))
mse.like <- mse.el <- mse.init <- bias.like <- bias.init <- bias.el <- rep(0, sim.size)
ci.like <- rep(0, sum(mod$B))
for(i in 1:sim.size){
cat(paste(i,": "))
Y <- t(MASS::mvrnorm(n = n, Sigma = Sigma, mu = rep(0, V)))
#   ln.var <- 1
#   ln.mu <- 0
#   errors <- matrix(rlnorm(v * n, meanlog = ln.mu, sdlog = sqrt(ln.var)), nrow = v, ncol = n)
#   errors <- (errors - exp(ln.mu + ln.var/2)) / sqrt((exp(ln.var) - 1) * exp(2*ln.mu + ln.var))
#   Y <- solve(diag(rep(1, v)) - B.true, t(chol(Omega.true)) %*% errors)
Y <- Y - rowMeans(Y)
#### RICF Procedure ####
out_ricf <- ricf(B = mod$B, Omega = mod$Omega, Y = Y, BInit = NULL,
OmegaInit = NULL, sigConv = 0, maxIter = 10000,
msgs = FALSE, omegaInitScale = .8, tol = 1e-6)
I <- ricf_info(S = mod$Sigma, BHat = out_ricf$BHat, OmegaHat = mod$Omega.true,
B = mod$B, Omega = mod$Omega)
beta.like <- out_ricf$BHat[which(mod$B==1)]
mse.like[i] <-  mean((beta.like - mod$B.true[which(mod$B==1)])^2)
bias.like[i] <- mean(beta.like - mod$B.true[which(mod$B==1)])
se.like <- sqrt(diag(solve(I))/n)[1:sum(mod$B)]
ci.like <- ci.like +  (abs(beta.like - mod$B.true[which(mod$B==1)]) / se.like < qnorm(.975))
##### EL Procedure #####
#   out_ricf_init <- ricf(B = mod$B, Omega = mod$Omega, Y = mod$Y, BInit = NULL,
#                         OmegaInit = NULL, sigConv = 0, maxIter = 5,
#                         msgs = FALSE, omegaInitScale = .9)
#
#
#   num_dual_vars = V + sum(mod$Omega == 0)/2
#   init_val = c(out_ricf_init$BHat[mod$B==1])
#   mse.init[i] <- mean((init_val - mod$B.true[which(mod$B==1)])^2)
#   bias.init[i] <- mean(init_val - mod$B.true[which(mod$B==1)])
#
#   optim_out <- optim(par = init_val, fn = sem_el_fit_obj, gr = NULL,
#                      y_r = mod$Y, omega_r = mod$Omega, b_r = mod$B,
#                      dual_r = rep(0, num_dual_vars), tol = 1e-6, max_iter = 60,
#                      meanEst = 0,
#                      method = "BFGS", control = list(fnscale = -1))
#
#   fitted_mod <- sem_el_fit_weights(optim_out$par,y_r = mod$Y, omega_r = mod$Omega, b_r = mod$B,
#                                    dual_r = rep(0, num_dual_vars), tol = 1e-6, max_iter = 100, meanEst = 0)
#   B.hat <- matrix(0, nrow = V, ncol = V)
#   B.hat[mod$B==1] <- optim_out$par
#
#   # sw <- empLike_sandwich(Y, mod$B, mod$Omega, B.hat, c(1/fitted_mod$d))
#
#   beta.el <- B.hat[which(mod$B==1)]
#   mse.el[i] <- mean((optim_out$par - mod$B.true[which(mod$B==1)])^2)
#   bias.el[i] <- mean(optim_out$par - mod$B.true[which(mod$B==1)])
#   se.el <- sqrt(diag(sw$sw.var)/n)
#   ci.el <- ci.el +  (abs(beta.el - mod$B.true[which(mod$B==1)]) / se.el < qnorm(.975))
}
ci.like / sim.size
# ci.el / sim.size
#
# mean(bias.like)
# mean(bias.el)
# mean(bias.init)
#
# mean(mse.like, trim = .05)
# mean(mse.el)
# mean(mse.init)
#
# count <- 1
beta.like
abs(beta.like - mod$B.true[which(mod$B==1)]) / se.like
se.like
I
diag(solve(I))
eigen(I)
round(I, 5)
I
isSymmetric(I)
diag(I)
Omega <- mod$Omega
OmegaHat <- mod$Omega.true
B <- mod$B.true
B <- mod$B
BHat <- mod$B.true
V <- dim(B)[1]
### Create P Matrix ####
P <- matrix(0, nrow = V^2, ncol = sum(B))
temp <- matrix(c(which(c(B)==1),1:sum(B)), nrow = sum(B), ncol = 2)
P[temp] <- 1
Q <- matrix(0, nrow = V^2, ncol = (sum(Omega)-V)/2 + V)
Omega.temp <- matrix(0, nrow = V, ncol = V)
count <- 0
for(i in 1:V){
for(j in i:V){
if(Omega[i,j] == 1){
count <- count + 1
Omega.temp[i,j] <- count
}
}
}
Omega.temp <- Omega.temp + t(Omega.temp) - diag(diag(Omega.temp))
Q[cbind(c(1:V^2), c(Omega.temp))] <- 1
P
B
B.temp <- matrix(0, nrow = V, ncol = V)
B.temp[3,1] <- 1
B.temp[5,2] <- 2
B.temp[1,3] <- 3
B.temp *B
B
P %*% B.temp
P
dim(B)
dim(P)
(P %*% c(1:3)) == c(B.temp)
i.minus.b
i.minus.b <- diag(rep(1, V)) - BHat
c(t(i.minus.b)) == Tr %*% c(i.minus.b)
Tr <- matrix(0, nrow = V^2, ncol = V ^2)
Tr[matrix(c(1:V^2, (rep(c(1:V), V)-1) *V + rep(c(1:V), each = V)), ncol = 2)] <- 1
c(t(i.minus.b)) == Tr %*% c(i.minus.b)
c(t(i.minus.b))
I <- matrix(0, nrow = sum(B) + (sum(Omega)-V)/2 + V,
ncol = sum(B) + (sum(Omega)-V)/2 + V)
I
eigen(I)
I <- matrix(0, nrow = sum(B) + (sum(Omega)-V)/2 + V,
ncol = sum(B) + (sum(Omega)-V)/2 + V)
I[1:sum(B), 1:sum(B)] <- t(P) %*% (S %x% omega.inv + (eye.minus.b.inv %x% t(eye.minus.b.inv)) %*% Tr) %*% P
I[-c(1:sum(B)),-c(1:sum(B))] <- 1/2 * t(Q) %*% (omega.inv %x% omega.inv) %*% Q
I[c(1:sum(B)),-c(1:sum(B))] <- t(P) %*% ( eye.minus.b.inv %x% omega.inv) %*% Q
I[-c(1:sum(B)),c(1:sum(B))] <- t(Q) %*% (t(eye.minus.b.inv) %x% omega.inv) %*% P
S
s <- mod$Sigma
S <- mod$Sigma
V <- dim(B)[1]
### Create P Matrix ####
P <- matrix(0, nrow = V^2, ncol = sum(B))
temp <- matrix(c(which(c(B)==1),1:sum(B)), nrow = sum(B), ncol = 2)
P[temp] <- 1
Q <- matrix(0, nrow = V^2, ncol = (sum(Omega)-V)/2 + V)
Omega.temp <- matrix(0, nrow = V, ncol = V)
count <- 0
for(i in 1:V){
for(j in i:V){
if(Omega[i,j] == 1){
count <- count + 1
Omega.temp[i,j] <- count
}
}
}
Omega.temp <- Omega.temp + t(Omega.temp) - diag(diag(Omega.temp))
Q[cbind(c(1:V^2), c(Omega.temp))] <- 1
omega.inv <- solve(OmegaHat)
eye.minus.b.inv <- solve(diag(rep(1, V)) - BHat)
Tr <- matrix(0, nrow = V^2, ncol = V ^2)
Tr[matrix(c(1:V^2, (rep(c(1:V), V)-1) *V + rep(c(1:V), each = V)), ncol = 2)] <- 1
I <- matrix(0, nrow = sum(B) + (sum(Omega)-V)/2 + V,
ncol = sum(B) + (sum(Omega)-V)/2 + V)
